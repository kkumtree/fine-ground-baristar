# 따로 공부하기 [21.01.16.]

> 참고자료
- https://catch-me-java.tistory.com/9?category=438116

## 목표
> JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가
- 컴파일 하는 방법
- 실행하는 방법
- 바이트코드란 무엇인가
- JIT 컴파일러란 무엇이며 어떻게 동작하는지
- JVM 구성 요소
- JDK와 JRE의 차이

## 정리 내용
1. 바이트코드? : JVM이 이해할 수 있는 기계어. (중간코드라고도 함)
	> JVM은 바이트코드를 해당 OS의 기계어로 변환하여 OS에 전달함.
	- javap는 바이트 코드를 우리가 볼 수 있는 형태로 바꾸어준다.
	> 기능
	1. 프로그램 분석: 코드에서 버그 찾는 툴, 코드 복잡도 계산
 	2. 클래스 파일 생성: 프록시, 특정API 호출 제한, 타 언어의 컴파일러 만들기
2. JVM과 JIT 컴파일러?
	> JDK -> JRE -> JVM
	- JDK: 개발킷. 컴파일러/역 어셈블러/디버거/의존관계 분석 등 개발에 필요한 도구를 제공
	- JRE: 런타임환경. JVM으로 보내주는 바이트코드 생성. 개발도구 미포함.
	자바 실행명령, 클래스 로더와 바이트코드 실행에 필요한 라이브러리 제공.
	- JVM: OS 독립적으로 실행가능한 추상층 제공(=바이트코드를 OS에 맞춘다).
	이때 인터프리터와 JIT를 사용
	> JIT 컴파일러? : 자바는 컴파일 방식과 인터프리터 방식을 모두 사용함.
	- 한번 읽어서 기계어로 변경한 소스코드는 번역하지(물론 다시 읽지도) 않는다.
3. JVM 구조? : 왜째서 Virtual Box가 뇌리를 스치는거냐...
	> Class Loader / JVM Memory[구조 꼭 볼 것!] / Execution Engine
	- 클래스 로더 시스템: 로딩 -> 링크 -> 초기화
	- 메모리: 힙, 메소드, PC레지스터, 스택, 네이티브 메소드 스택
		- 힙: 인스턴스화 된 모든 클래스 인스턴스와 배열을 저장.
		모든 JVM스레드에 공유되는 자원, 무조건 가비지 컬렉터에 의해서만 회수 가능.
		- 메소드: 클래스 수준의 정보(런타임 상수풀, 필드와 메소드 데이터) 저장.
		JVM을 만드는 회사마다 메소드의 영역의 위치는 상이할 수 있다.
		다만, 스펙상 논리적으로는 메소드 영역이 힙의 일부이기에 가비지 컬렉션 대상이 된다고 한다.
		- PC레지스터: CPU레지스터와는 다르게, 피연산자 임시 저장용도로 사용.
		- 스택(=JVM스택): 스레드마다 런타임 스택을 만들고, 이 스택에 프레임이 저장.
		단위 메소드가 호출될 때, 새 프레임 생성되고 스택에 쌓인다. 메소드 호출의 완료/예외 시 프레임은 스택에서 빠지면서 소멸, 스레드 종료 시 스택이 제거된다.
		- 네이티브 메소드 스택(=C스택): 타 언어로 작성된 네이티브 메소드를 지원하기 위한 스택.
		스택과 마찬가지로 스레드 단위의 자료구조.
	- 실행엔진: 클래스 로딩 과정을 통해 런타임 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행.
4. JDK / JRE / JVM
	> Java SE 8에는 JRE만 따로 설치가 가능.
	Java SE 11부터는 무조건 JRE가 JDK에 동봉.
	- JDK
		- 자바 프로그램을 작성하고, JRE를 실행하는데 필요한 툴들이 있음.
		- 컴파일러(javaC)와 자바 어플리케이션 런처, Appletiviewer 등을 포함.
		- 컴파일러: '자바코드 -> 바이트코드'로 변경.
		- 자바 어플리케이션 런처: JRE를 실행하는데 필요한 클래스, 메인 메서드를 로딩.
	- JRE
		- 있는 것: 클래스 라이브러리, JVM, 여러 Supporting 파일들.
		- 없는 것: Debuger와 Compiler과 같은 개발 도구.
		- JRE match, swingetc, util, lang, awt 그리고 런타임 라이브러리 같은 패키지를 가지고 있음.
		- Java applets을 사용하려면 JRE가 있어야한다.

| JDK | JRE | JVM |
|:---:|:---:|:---:|
| 개발자킷. 개발에 필요한 어플리케이션 | 소프트웨어 번들. 자바 클래스, 라이브러, 필수 컴포넌트 제공 | 바이트코드를 실행하고, 실행에 필요한 환경 제공 |
| 플랫폼 독립적 | 플랫폼 독립적 | 플랫폼 **'종속적'** |

<p></p>

## 해당 내용이 헷갈릴 때 찾아봐야하는 문서(강권수준)
- JIT 내부동작방식(원어): https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/
- 메모리 영역의 도표: https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/

## (뱀다리)
- JNI?: 위에 언급된 네이티브 메소드를 호출하는 방법을 제공한다고 한다.
	> 그래서 왜 사용하는 건데?
	- 자바로 동일한 코드를 재작성하기를 원치 않을 때 (상당히 크고 중요한 타 언어 코드)
	- 시스템 디바이스에 접근하거나, 특정 플랫폼의 작업을 할때.
	- 자바로 구현하기엔 속도 저하가 예상되서, 성능향상을 추구할 때(C언어라던지..)
	> But! Effective Java에서는 native method 사용을 자제해야한다고 한다. (CPP의 friends 같은 건가 보다.)
	- https://itstory.tk/entry/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-%EA%B7%9C%EC%B9%9954-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC

